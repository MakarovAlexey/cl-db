* Mapping definition
** TODO Добавить проверку наличия отоборажения названий столбцов первичного ключа
* Connection managment
* Session managment
* Query
  1) полиморфные запросы - вычисление таблиц и связей до подклассов
     если такоевые указаны.
  2) вычисление таблиц и связей необходимых только для загрузки
     указанного в спеске выбора
     
  |             | select list | from | where | order-by | having |
  |-------------+-------------+------+-------+----------+--------|
  | property    | X           | -    | X     | X        | X      |
  | many-to-one | -           | X    | -     | X        | ?      |
  | one-to-many | -           | X    | -     | -        | -      |
  | root        | -           | X    | -     | -        | -      |
  | superclass  | -           | X    | -     | -        | -      |
  | subclass    | -           | X    | -     | -        | -      |
** arguments  
   - select-list - joned-list
   - where - joined-list
   - from select-list + where
   - group-by - select-list - argegate expressions
   - having - select-list
   - order-by - select-list
   - fetch - select-list

** db-read (criteria-or-list &key select-list transform fetch-also where order-by having offset limit)
    |             | root      | superclass          | subclass  |
    |-------------+-----------+---------------------+-----------|
    | select-list | property  | property, reference | -         |
    | where       | property  | property            | -         |
    | order-by    | property  | property            | -         |
    | having      | property  | property            | -         |
    | from-clause | table     | inner-join          | left-join |
    | fetch-also  | reference | reference           | reference |
    | loaders     | property  | property            | property  |
    | transform   | -         | -                   | -         |
*** select-list
    Ключевые параметры на основе ассоциативного списока-дерева по
    классам (псевдонимам) и названию слотов-свойств с учетом
    псевдонимов таблиц.
    - alias (keyword)
      + property-name
      + alias
      + column-name
    - список включает классы ссылок (свойства присоединенных ссылок),
      свойства запрашиваемого класса и свойства подклассов (?)
    - при условии, что для различных criteria заданы псевдонимы, а в
      иерархиях запрашиваемых классов отсутсвует перегрузка
      отображения слотов, то можно объединить все отображаемые
      свойства под одним псевдонимом criteria
      #+NAME: Fetching
      #+BEGIN_SRC lisp
        (list (cons alias (list (cons slot-name table-alias column-name))))
        :select-list #'(lambda &key alias)
                       (expression-eq alias property-name value))
      #+END_SRC
    - По описанию списка выборки создается секция group by
*** join (reference)
    Необходим ассоциативный список-дерево по классам и названию
    слотов-ссылок.
    - class-name
      + reference-name
      + alias (of class-mapping to join)
      + many-to-one: alias, foreign-key или one-to-many: alias,
        primary-key
*** fetch
    Принимает отображения (criteria) по псевдонимам.

    Во-первых, указание словий выборки по ассоциациям не исключает
    загрузки ассоциаций целиком. Поэтому, fetch нужно указывать
    отдельно. Кроме того, абстрагирование, что является в виде
    иерархий классов, не только отрицание конкретного (особых слотов
    подклассов), но также содержит его в себе. Поэтому, при отсутствии
    перегрузки слотов, ассоциации подклассов можно перечислить вместе
    с ассоциациями надклассов.

    #+NAME: Fetching
    #+BEGIN_SRC lisp

    (db-read (make-critera 'project :project)
             :select-list #'(lambda (&key project)
                              (list (property 'name-of project) project)
	     :fetch-also #'(lambda (name project)
                             (declare (ignore name))
		 	     (fetch project #'project-participations-of
				    #'(lambda (participation)
				        (values
					 (fetch participation #'user-of)
				         (fetch participation #'projects-of))))))) ;; of subclass
      #+END_SRC
    - При появлении секции GROUP BY, основной запрос (кроме ассоциаций
      группы fetch), выполняется в подзапросе.
    - При наличии select-list, возвращаемое им значение передается в
      fetch как обязательные параметры. Соответственно, описывать
      загружаемые ассоциации необходимо для объектных отображений, а
      не для выражений загрузки значений (avg, max и т.д.)
    - Загрузка ассоциаций (присвавание объекту слоту) происходит в
      контексте объекта (первичного ключа), поэтому знать класс
      объекта не нужно
*** transform
    lambda-выражение преобразующее результат.
    #+BEGIN_SRC lisp
      #'(lambda (&rest projects)
          (mapcar #'(lambda (project)
                      (list (name-of project) (begin-date-of project))) projects))
    #+END_SRC
*** where
    Аналогично select-list. Нужно учесть, что условия по слотам
    подклассов затрагивают записи не относящиеся к этим
    объектам. Условие может сработать неправильно из-за отсутствия
    свойства подкласса у надклассов, что привдет к загрузке только
    объектов подкласса. Поэтому, список свойств для условий необходимо
    ограничить только свойстами иерархии надклассов и запрашиваемого
    класса.
*** order-by
    Аналогично select-list.
*** having
    Аналогично where.
*** offset
    Число.
*** limit
    Число.
** Query building
   Таблицы присоединяются в запросе только по необходимости. Набор
   таблиц зависит от указанных в запросе объектов. Отсюда следует, что
   каждое отображение слота или объекта имеет свой набор объединяемых
   таблиц.

   Все объекты отображения слотов являются лямбда-выражениями которые
   возвращают три значения:
   - список столбцов
   - загрузочник
   - список таблиц (FROM-clause)
     
   Отображения объектов также возвращают ссылки и свойства (как
   lambda-выражения в ассоциативном списке по эффективным определениям
   слотов).
** loaders
   Для загрузочников необходимо:
   - Класс объекта
   - Первичный ключ
   
   Значения слотов, ссылки и свойства, загружаются отдельно.

   Загрузка свойств - чтение значения одной колонки. Загрузка
   отношений "много к одному" - загрузка объектов отношения, как
   ассоциативного списка по ключу.  Загрузка отношения типа "один ко многим"

   - Ассоциативное дерево свойств (properties) по классам (для класса,
     присоединенных ссылок (ауеср) и подклассов) для select-list db-read
   - Ассоциативное дерево ссылок (many-to-one и one-to-many) по
     классам (для класса, и подклассов) для fetch
   - FROM-clause
   - у любого выражения (expression) загружается только результат ---
     значение
   - у любого связывания (binding), объекта или ассоциций загружается
     объект
*** fetch
    Загрузка ассоциаций (ссылок). Планирование ссылков идет также как
    обычных объектов. Для join это приемлемо, для fetch - нет, так как
    нужно знать тип ассоциации (many-to-one,
    one-to-many). Соответсвенно, для fetch загрузочник будет другим.
    
    Для many-to-one он будет выглядеть как загрузочник свойств. Для
    one-to-many он будет 

    Если при заданном fetch будет заданы параметры ограничивающие
    выборку ("limit", "offset", where, агрегирование выборки (будет
    секция group by)). То нужно отделить основной запрос от fetch,
    разместив основной запрос в подзапросе или в выражении "with".
*** DONE Query trees
    Для анализа таблиц и связей необходимо локализовать обращения из
    выражений из select-list where having order-by в дерево отображения
    root-mappings

    Это даст возможность определить таблицы и их связи для формирования
    FROM-выражения

    аналог FROM содержится в select-list как корневые объекты для
    запроса.

    Затем создаем структуру запроса отражая связи между таблицами
    (table-reference). Попутно указываем ссылки и выражения на основе
    которых создана связь.
    
    Анализ связей для загрузочников объектов.
    
    В таком случае, при загрузке ассоциаций вместе с объектами
    некоторой иерархии. Загрузка ассоциации будет проводиться по свом
    объекдинениям таблиц, а сам класс по своим.
    
    Необходимо реализовать возможность использования таблиц иерархии
    наследования для обращений к значениям слотов и ассоциациям.
    
    Таким образом в запросах не будет избыточного количества
    объединений таблиц.
    
    Поэтому, query-node суперкласс иерархии подклассами которой будет
    структура запроса в каноническом виде - от корня к листям (в
    противоположность переданных в запрос выражения в обычном виде, от
    листьев к корням). Данный граф можно будет использовать для
    генерации всех частей запроса (FROM, WHERE, ORDER BY, HAVING) и для
    загрузки результатов запроса (select list loaders).
    
    Подклассы: object-loader, value-access-loader,
    expression-result-loader.
    
    NB: данные подклассы используются только для отметки мест загрузки
    результата (select list).

    После дерева необходимо заново вычислить все объекты запроса.
    Затем по очереди вычислить:
    1. FROM clause
    2. select
*** SQL Query
**** Fetch-also
     При наличии загружаемых ассоциации, создается объединение с
     подзапросом - в котором загружается основная информация.

     Псевдонимы полей запроса уникальны во всем запросе.
**** limit and offset
     LIMIT - ограничение количества загружаемых объектов. OFFSET -
     загрузить только объекты начинающиеся с определенной позиции.
     Необходимо предусмотреть, чтобы трансляция в SQL была адекватной
     этим установкам.
**** Single instance
     Single - имеет смысл только при поиске одного объекта. Надо
     сделать так, чтобы single работал с fetch-also (учесть в запросе)
**** FROM clause
**** Select list
**** WHERE clause
     

**** Варианты построения запроса

     1) Строится основной запрос.
     2) Если fetch-ассоциации которые не получается загрузить с
        основными даннымии (узлы reference-node содержат только узлы
        из fetch) и указан параметр limit, то строится над-запрос
        который присоединяет данные ассоциации к основному запросу.
     3) Если параметр limit не указан, то созхдается новый запрос
        который ключает в себя ассоциации

	Получается, что построение запроса происходит в два этапа. На
        первом строится AST за вычетом fetch-ассоциаций. Вторым, AST
        достраивается с учетом этих ассоциаций.
	
	Короче. При обходе структурного дерева запроса нужно
        пропускать добавление в select-list полей для fetch-ассоциаци
        при заданном параметре limit, в from избегать добавления
        улозов относящихся только к fetch-ассоциациям.
	
	Таким образом, нужно построить отдельное дерево, без узлов с
        fetch-ассоциациями. Тут, скорее всего, речь идет уже о
        построении основной части AST запроса.

	AST запроса - это список источников с указанием элементов для
        включения в select-list.

	;; Query plan
(defclass object-node ()
  ((superclass-nodes :initarg :superclass-nodes
		     :reader superclass-nodes-of)
   (reference-nodes :initarg :reference-nodes
		    :reader reference-nodes-of)
   (value-nodes :initarg :value-nodes
		:reader value-nodes-of)))

(defclass root-binding-node (object-node)
  ((root-binding :initarg :root-binding
		 :reader root-binding-of)))

(defclass reference-node (object-node)
  ((reference-mapping :initarg :reference-mapping
		      :reader reference-mapping-of)
   (reference-bindings :initarg :reference-bindings
		       :reader reference-bindings-of)))

(defclass superclass-node (object-node)
  ((inheritance-mapping :initarg :inheritance-mapping
			:reader inheritance-mapping-of)))

(defclass value-node ()
  ((value-mapping :initarg :value-mapping
		  :reader value-mapping-of)
   (value-bindings :initarg :value-bindings
		   :accessor value-bindings-of)))

*** Вычисление select list запроса

    Сначала создаем список FROM-clause. Table-reference и joins.

**** root-binding

     Вычисляется, как набор колонок (колонки таблицы плюс
     наледование).

**** reference-binding

     Вычисляется также, набор колонок, как root-binding, только
     reference-binding.

**** value-binding

     По parent-mapping находим table-reference.

**** expression

     По ситуации находим нужные колонки первичных ключей или колонок
     значений.
** Result loading (loaders)
   Результат запроса обрабатывается двумя загрузчиками:
   1. объектный загрузчик (object loader). Нужны все данные по
      объектам из БД ассциации загружаются также, объектным
      загрузчиком.
   2. загрузчик результата выражения (expression loader) Нужна только
      часть, участвующая в выражении. Надо собрать информацию о
      привязках используемых для в запросе.

      Создаем query-loader. Здесь, root-bindings и refrence-bindings,
      как связующие звенья, снимаются и предстают в виде отношений
      таблиц.  Ссылки на них могут остаться только, как
      резултат. Здесь отношения таблиц можно переводить в SQL как
      выражение "FROM". Осталось создать загрузочники для select-list.

      Для этого необходимо собрать загружаему информацию по дереву.
      Делается это обходом дерева до нижнего уровня. В ходе этого
      необходимо собрать информацию о таблицах.
      
      Для загрузки результата-объекта необходима иерархическая
      структура. Причем загрузка происходит от самых частных классов
      объектов к самым общим. Следовательно, нужно создать загрузочники
      результата (select item).

      Select item может возвращать результат как список списков
      (несколько значений в одной строке) так и одно значение.
*** Indexing
    Первичный ключ для каждого класса объектов может быть свой. Таким
    образом каждый объект имеет нескольько первичных ключей по одному
    на каждый надкласс. Хэштаблица по названию класса.
*** Query plan
    После того, как построен план запроса, определяется, какие узлы, к
    каким элементам списк азапросов относятся. Таким образом можно
    найти то, что нужно запросить и загрузить.
** Aggregate functions
*** AVG(expression)
    Computes the average value of a column given by expression
*** CORR(dependent, independent)
    Computes a correlation coefficient
*** COUNT(expression)
    Counts the rows defined by the expression
*** COUNT(*)
    Counts all rows in the specified table or view
*** COVAR_POP(dependent, independent)
    Computes population covariance
*** COVAR_SAMP(dependent, independent)
    Computes sample covariance
*** CUME_DIST(value_list) WITHIN GROUP (ORDER BY sort_list)
    Computes the relative rank of a hypothetical row within a group of
    rows, where the rank is equal to the number of rows less than or
    equal to the hypothetical row divided by the number of rows in the
    group
*** DENSE_RANK(value_list) WITHIN GROUP (ORDER BY sort_list)
    Generates a dense rank (no ranks are skipped) for a hypothetical
    row (value_list) in a group of rows generated by GROUP BY
*** MIN(expression)
    Finds the minimum value in a column given by expression
*** MAX(expression)
    Finds the maximum value in a column given by expression
*** PERCENT_RANK(value_list) WITHIN GROUP (ORDER BY sort_list)
    Generates a relative rank for a hypothetical row by dividing that
    row's rank less 1 by the number of rows in the group
*** PERCENTILE_CONT(percentile) WITHIN GROUP (ORDER BY sort_list)
    Generates an interpolated value that, if added to the group, would
    correspond to the percentile given
*** PERCENTILE_DISC(percentile) WITHIN GROUP (ORDER BY sort_list)
    Returns the value with the smallest cumulative distribution value
    greater than or equal to percentile
*** RANK(value_list) WITHIN GROUP (ORDER BY sort_list)
    Generates a rank for a hypothetical row (value_list) in a group of
    rows generated by GROUP BY
*** REGR_AVGX(dependent, independent)
    Computes the average of the independent variable
*** REGR_AVGY(dependent, independent)
    Computes the average of the dependent variable
*** REGR_COUNT(dependent, independent)
    Counts the number of pairs remaining in the group after any pair
    with one or more NULL values has been eliminated
*** REGR_INTERCEPT(dependent, independent)
    Computes the y-intercept of the least-squares-fit linear equation
*** REGR_R2(dependent, independent)
    Squares the correlation coefficient
*** REGR_SLOPE(dependent, independent)
    Determines the slope of the least-squares-fit linear equation
*** REGR_SXX(dependent, independent)
    Sums the squares of the independent variables
*** REGR_SXY(dependent, independent)
    Sums the products of each pair of variables
*** REGR_SYY(dependent, independent)
    Sums the squares of the dependent variables
*** STDDEV_POP(expression)
    Computes the population standard deviation of all expression
    values in a group
*** STDDEV_SAMP(expression)
    Computes the sample standard deviation of all expression values in
    a group
*** SUM(expression)
    Computes the sum of the column values given by expression
*** VAR_POP(expression)
    Computes the population variance of all expression values in a
    group
*** VAR_SAMP(expression)
    Computes the sample standard deviation of all expression values in
    a group
** Scalar functions
** Schedule
** Object quering and loading
*** SQL select list and select list from clause parts
*** SQL where clause and from clause parts
*** fetching reference
*** Quering and loading single object
** Object persistence (inserting and updateing queries)
** Selecting values (slot values, functions, aggegation)
** Query examples
** Рекурсиваня выборка
   Все рекрусивные вызовы в объектом запросе должны аккумулироваться в
   `WHERE' рекурсивной части `WITH' разделенных оператором `OR'.

   #+NAME: Выборка бинарного дерева
   #+BEGIN_SRC sql
     -- binary tree
     
     CREATE TABLE tree_nodes (
            id integer,
            node_value varchar,
            PRIMARY KEY (id)
     );
     
     CREATE TABLE left_nodes (
            id integer,
            tree_node_id integer,
            PRIMARY KEY (id),
            FOREIGN KEY (id) REFERENCES tree_nodes (id),
            FOREIGN KEY (tree_node_id) REFERENCES tree_nodes (id)
     );
     
     CREATE TABLE right_nodes (
            id integer,
            tree_node_id integer,
            PRIMARY KEY (id),
            FOREIGN KEY (id) REFERENCES tree_nodes (id),
            FOREIGN KEY (tree_node_id) REFERENCES tree_nodes (id)
     );
     
     INSERT INTO tree_nodes (id, node_value) VALUES
                 (1, 'четыре'),
                 (2, 'два'),
                 (3, 'шесть'),
                 (4, 'один'),
                 (5, 'три'),
                 (6, 'пять'),
                 (7, 'семь');
     
     INSERT INTO left_nodes (tree_node_id, id) VALUES
                 (2, 1),
                 (4, 2),
                 (6, 3);
     
     INSERT INTO right_nodes (tree_node_id, id) VALUES
                 (3, 1),
                 (5, 2),
                 (7, 3);
     
     -- plain
     
     SELECT tree_nodes.id, tree_nodes.node_value,
            left_nodes.tree_node_id, right_nodes.tree_node_id
       FROM tree_nodes
       LEFT JOIN left_nodes
         ON left_nodes.id = tree_nodes.id
       LEFT JOIN right_nodes
         ON right_nodes.id = tree_nodes.id
     
     -- recursive with `WHERE' clause
     
     WITH RECURSIVE children (id, node_value, left_node_id, right_node_id) AS (
          SELECT tree_nodes.id, tree_nodes.node_value,
                 left_nodes.tree_node_id, right_nodes.tree_node_id
            FROM tree_nodes
       LEFT JOIN left_nodes
              ON left_nodes.id = tree_nodes.id
       LEFT JOIN right_nodes
              ON right_nodes.id = tree_nodes.id
           WHERE tree_nodes.id = 1
           UNION ALL
          SELECT tree_nodes.id, tree_nodes.node_value,
                 left_nodes.tree_node_id, right_nodes.tree_node_id
            FROM children, tree_nodes
       LEFT JOIN left_nodes
              ON left_nodes.id = tree_nodes.id
       LEFT JOIN right_nodes
              ON right_nodes.id = tree_nodes.id
           WHERE tree_nodes.id = children.left_node_id
              OR tree_nodes.id = children.right_node_id)
     
     SELECT id, node_value, left_node_id, right_node_id
       FROM children;
     
   #+END_SRC
** SQL-операторы и функции
** Переделать функцит для select-list
   - class-mapping (columns, from-clause, group-by-clause, properties, references)
   - properties (columns, from-clause, group-by-clause)
   - references (columns, from-clause, group-by-clause, properties, references)
   - expressions (columns (expression), from-clause, group-by-clause)
     #'(lambda (&key expression from-clause group-by-clause properties references))

** ORDER BY
  Сортировка выборки.
  
* Интерпретация значений NULL
  Возможно следует исходить из спецификации типа слота, когда тип в
  общем виде `(or null t)' будет означать, что значение должно быть
  интерпретировано как nil. Если тип указан только как `t', то NULL
  должен быть интерпретирован как отсутствие значение (unbound slot).

  Такой подход сработает для свойств и отношений `много-к-одному', но
  для отношений `один-ко-многим' это относится не может, так как оно
  всегда представляет коллекцию объектов, пусть даже пустую.

  При этом, для many-to-one несвязанный слот не всегда будет отражать,
  что его значение просто не загружено из БД. Эту информацию нужно
  будет хранить отдельно.

  Также возникнут трудности с возможностью делать слот несвязанным
  (`slot-makunbound'). 

  Пока поступим проще.
** property
   NULL базы данных всегда интерпретируется как nil.
** many-to-one
* Persisitence
** New
   
** Loaded
** Removed
** Query stack
   Запись изменений производится в два этапа:
   1. Построение стэка команд-запросов в разрезе объектов. На данном
      этапе происходит вычисление изменений данных и общая проверка
      данных на согласованность определенной схеме данных.
   2. Отправка команд в СУБД. На данным этапе также происходит
      дополнительная проверка изменений на согласованность данных
      которые не были загружены в течении сессии. Например, ведется
      проверки возможности удаления объекта, проверка отсутствия
      ссылок других объектов на данных объект.

      "DELETE FROM table
        WHERE id = 123
          AND (SELECT count(*) FROM refs WHERE id = 123) = 0"
*** Обработка циркулярных ссылок
    Прежде чем поместить граф объеков в стек, нужно обойти этот граф 
** Реализация
   Пройтись по списку новых объектов.  Каждый объект обойти как
   граф. Добавить обработанное состояние объекта в список.
   
   Для каждого объекта инвертировать отношение
   "один-ко-многим". Вычислить добавленные и обновленные объекты
   исходя из отношений "один-ко-многим".

   - Вычислить измененые отношения "много-к-одному" и свойства.
   - В состояние объекта добавить информацию по добавленным в
     коллекцию объектам и удаленным. (one-to-many-appendings,
     one-to-many-removings)
   - Наличие транзитивных объектов возможно только в изменных
     коллекциях. Поэтому проверять состояние объектов исходного
     состояния коллекции не нужно. Новую, также, не нужно проверять
     полностью. Нужно проверить состояние только у вновь добавленныХ в
     коллекцию объектов, попутно придется пройтись по удаленным из
     коллекции объектам. Остальные объекты загружны и будут обработаны
     при обходе списка загруженных объектов.
** Bidirectional associations
   Измененное состояние один-ко-многим. Хранение состояния ассоциации
   в обращенной форме - слот инвретированных ассоциаций.
