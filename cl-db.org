
 1) полиморфные запросы - вычисление таблиц и связей до подклассов
    если такоевые указаны.

 2) вычисление таблиц и связей необходимых только для загрузки
    указанного в спеске выбора

 

* Mapping definition
* Quering
** Query building
   у любого выражения (expression) загружается только результат ---
   значение

   у любого связывания (binding), объхекта или ассоциций загружается
   объект

   Собираем информацию о данных участвующих в запросе. Строим
   query-info.

   когда надо назначать псевдонимы таблцам? Ведь они важны для
   загрузки.

   Для загрузки объекта - создется загрузочник объекта в котором вся
   эта информация есть. Для загрузки значения выражения требуются
   только связи между таблицами.

   Какую информацию необходимо сообщить загрузчику значения?
       	
   Сперва создаем отображение запроса (query-mappings). Результатом
   будет список объектов query-mapping. Они понадобятся для построения
   загрузочников. В отображении участвуют связывания.

   select-list:
   objects
   values
   operators
   function calls
   aggregate function calls

   symbol - alias of from clause
   sexp
   (defun compile-expression (expression)
   
   (defun compile-select-list (&rest expressions)
   (mapcar #'compile-expression expressions))
   
   желательно реализовать компиляцию запросов с сохранением
   результатов в конфигурации сессии
   
   каждый запрос сопоставлен с символом (как функция принимающая
   подключение и возвращающая результат запроса)
   1. синтакический разбор запроса
   2. компиляция вместе с OR-отображением через вызов (compile-mappings)
*** DONE Query trees
    Для анализа таблиц и связей необходимо локализовать обращения из
    выражений из select-list where having order-by в дерево отображения
    root-mappings

    Это даст возможность определить таблицы и их связи для формирования
    FROM-выражения

    аналог FROM содержится в select-list как корневые объекты для
    запроса.

    Затем создаем структуру запроса отражая связи между таблицами
    (table-reference). Попутно указываем ссылки и выражения на основе
    которых создана связь.
    
    Анализ связей для загрузочников объектов.
    
    В таком случае, при загрузке ассоциаций вместе с объектами
    некоторой иерархии. Загрузка ассоциации будет проводиться по свом
    объекдинениям таблиц, а сам класс по своим.
    
    Необходимо реализовать возможность использования таблиц иерархии
    наследования для обращений к значениям слотов и ассоциациям.
    
    Таким образом в запросах не будет избыточного количества
    объединений таблиц.
    
    Поэтому, query-node суперкласс иерархии подклассами которой будет
    структура запроса в каноническом виде - от корня к листям (в
    противоположность переданных в запрос выражения в обычном виде, от
    листьев к корням). Данный граф можно будет использовать для
    генерации всех частей запроса (FROM, WHERE, ORDER BY, HAVING) и для
    загрузки результатов запроса (select list loaders).
    
    Подклассы: object-loader, value-access-loader,
    expression-result-loader.
    
    NB: данные подклассы используются только для отметки мест загрузки
    результата (select list).
*** SQL Query
**** FROM clause
**** Select list
**** Other clauses
**** Single instance, limit and offset
** Result loading (loaders)
   Результат запроса обрабатывается двумя загрузчиками:
   1. объектный загрузчик (object loader). Нужны все данные по
      объектам из БД ассциации загружаются также, объектным
      загрузчиком.
   2. загрузчик результата выражения (expression loader) Нужна только
      часть, участвующая в выражении. Надо собрать информацию о
      привязках используемых для в запросе.

      Создаем query-loader. Здесь, root-bindings и refrence-bindings,
      как связующие звенья, снимаются и предстают в виде отношений
      таблиц.  Ссылки на них могут остаться только, как
      резултат. Здесь отношения таблиц можно переводить в SQL как
      выражение "FROM". Осталось создать загрузочники для select-list.

      Для этого необходимо собрать загружаему информацию по дереву.
      Делается это обходом дерева до нижнего уровня. В ходе этого
      необходимо собрать информацию о таблицах.
** Parameters
