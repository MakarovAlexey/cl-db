
 1) полиморфные запросы - вычисление таблиц и связей до подклассов
    если такоевые указаны.

 2) вычисление таблиц и связей необходимых только для загрузки
    указанного в спеске выбора

 

* Mapping definition
* Quering
** Query building
   у любого выражения (expression) загружается только результат ---
   значение

   у любого связывания (binding), объхекта или ассоциций загружается
   объект

   Собираем информацию о данных участвующих в запросе. Строим
   query-info.

   когда надо назначать псевдонимы таблцам? Ведь они важны для
   загрузки.

   Для загрузки объекта - создется загрузочник объекта в котором вся
   эта информация есть. Для загрузки значения выражения требуются
   только связи между таблицами.

   Какую информацию необходимо сообщить загрузчику значения?
       	
   Сперва создаем отображение запроса (query-mappings). Результатом
   будет список объектов query-mapping. Они понадобятся для построения
   загрузочников. В отображении участвуют связывания.

   select-list:
   objects
   values
   operators
   function calls
   aggregate function calls

   symbol - alias of from clause
   sexp
   (defun compile-expression (expression)
   
   (defun compile-select-list (&rest expressions)
   (mapcar #'compile-expression expressions))
   
   желательно реализовать компиляцию запросов с сохранением
   результатов в конфигурации сессии
   
   каждый запрос сопоставлен с символом (как функция принимающая
   подключение и возвращающая результат запроса)
   1. синтакический разбор запроса
   2. компиляция вместе с OR-отображением через вызов (compile-mappings)
*** DONE Query trees
    Для анализа таблиц и связей необходимо локализовать обращения из
    выражений из select-list where having order-by в дерево отображения
    root-mappings

    Это даст возможность определить таблицы и их связи для формирования
    FROM-выражения

    аналог FROM содержится в select-list как корневые объекты для
    запроса.

    Затем создаем структуру запроса отражая связи между таблицами
    (table-reference). Попутно указываем ссылки и выражения на основе
    которых создана связь.
    
    Анализ связей для загрузочников объектов.
    
    В таком случае, при загрузке ассоциаций вместе с объектами
    некоторой иерархии. Загрузка ассоциации будет проводиться по свом
    объекдинениям таблиц, а сам класс по своим.
    
    Необходимо реализовать возможность использования таблиц иерархии
    наследования для обращений к значениям слотов и ассоциациям.
    
    Таким образом в запросах не будет избыточного количества
    объединений таблиц.
    
    Поэтому, query-node суперкласс иерархии подклассами которой будет
    структура запроса в каноническом виде - от корня к листям (в
    противоположность переданных в запрос выражения в обычном виде, от
    листьев к корням). Данный граф можно будет использовать для
    генерации всех частей запроса (FROM, WHERE, ORDER BY, HAVING) и для
    загрузки результатов запроса (select list loaders).
    
    Подклассы: object-loader, value-access-loader,
    expression-result-loader.
    
    NB: данные подклассы используются только для отметки мест загрузки
    результата (select list).
*** SQL Query
**** Fetch-also
     При наличии загружаемых ассоциации, создается объединение с
     подзапросом - в котором загружается основная информация.

     Псевдонимы полей запроса уникальны во всем запросе.
**** limit and offset
     LIMIT - ограничение количества загружаемых объектов. OFFSET -
     загрузить только объекты начинающиеся с определенной позиции.
     Необходимо предусмотреть, чтобы трансляция в SQL была адекватной
     этим установкам.
**** Single instance
     Single - имеет смысл только при поиске одного объекта. Надо
     сделать так, чтобы single работал с fetch-also (учесть в запросе)
**** FROM clause
**** Select list
**** Other clauses

**** Варианты построения запроса

     1) Строится основной запрос.
     2) Если fetch-ассоциации которые не получается загрузить с
        основными даннымии (узлы reference-node содержат только узлы
        из fetch) и указан параметр limit, то строится над-запрос
        который присоединяет данные ассоциации к основному запросу.
     3) Если параметр limit не указан, то созхдается новый запрос
        который ключает в себя ассоциации

	Получается, что построение запроса происходит в два этапа. На
        первом строится AST за вычетом fetch-ассоциаций. Вторым, AST
        достраивается с учетом этих ассоциаций.
	
	Короче. При обходе структурного дерева запроса нужно
        пропускать добавление в select-list полей для fetch-ассоциаци
        при заданном параметре limit, в from избегать добавления
        улозов относящихся только к fetch-ассоциациям.
	
	Таким образом, нужно построить отдельное дерево, без узлов с
        fetch-ассоциациями. Тут, скорее всего, речь идет уже о
        построении основной части AST запроса.

	AST запроса - это список источников с указанием элементов для
        включения в select-list.

	;; Query plan
(defclass object-node ()
  ((superclass-nodes :initarg :superclass-nodes
		     :reader superclass-nodes-of)
   (reference-nodes :initarg :reference-nodes
		    :reader reference-nodes-of)
   (value-nodes :initarg :value-nodes
		:reader value-nodes-of)))

(defclass root-binding-node (object-node)
  ((root-binding :initarg :root-binding
		 :reader root-binding-of)))

(defclass reference-node (object-node)
  ((reference-mapping :initarg :reference-mapping
		      :reader reference-mapping-of)
   (reference-bindings :initarg :reference-bindings
		       :reader reference-bindings-of)))

(defclass superclass-node (object-node)
  ((inheritance-mapping :initarg :inheritance-mapping
			:reader inheritance-mapping-of)))

(defclass value-node ()
  ((value-mapping :initarg :value-mapping
		  :reader value-mapping-of)
   (value-bindings :initarg :value-bindings
		   :accessor value-bindings-of)))



** Result loading (loaders)
   Результат запроса обрабатывается двумя загрузчиками:
   1. объектный загрузчик (object loader). Нужны все данные по
      объектам из БД ассциации загружаются также, объектным
      загрузчиком.
   2. загрузчик результата выражения (expression loader) Нужна только
      часть, участвующая в выражении. Надо собрать информацию о
      привязках используемых для в запросе.

      Создаем query-loader. Здесь, root-bindings и refrence-bindings,
      как связующие звенья, снимаются и предстают в виде отношений
      таблиц.  Ссылки на них могут остаться только, как
      резултат. Здесь отношения таблиц можно переводить в SQL как
      выражение "FROM". Осталось создать загрузочники для select-list.

      Для этого необходимо собрать загружаему информацию по дереву.
      Делается это обходом дерева до нижнего уровня. В ходе этого
      необходимо собрать информацию о таблицах.
      
      Для загрузки результата-объекта необходима иерархическая
      структура. Причем загрузка происходит от самых частных классов
      объектов к самым общим. Следовательно, нужно создать загрузочники
      результата (select item).
** Parameters
    
